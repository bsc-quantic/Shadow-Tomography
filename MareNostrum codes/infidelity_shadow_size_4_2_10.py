import numpy as np
from numpy.linalg import norm
from qibo import Circuit, gates
from qibo.symbols import I, X, Y, Z
from qibo.optimizers import optimize
from qibo.quantum_info import infidelity
from qibo import set_backend

set_backend("numpy")
file = 0

""" Returns a classical shadow of size shadow_size of the state generated by circuit, where
each snapshot consists of an array of num_qubits 2 by 2 matrices"""
def calculate_classical_shadow(circuit, shadow_size, num_qubits):

    # Maps the Pauli measurements to the indeces 0, 1, 2 = X, Y, Z
    Pauli = [gates.X, gates.Y, gates.Z]

    # Measurement basis are chosen at random
    measurement_basis = np.random.randint(0, 3, size = (shadow_size, num_qubits))
    outcomes = np.zeros((shadow_size, num_qubits))

    for i in range(shadow_size):
        # In each snapshot, we perform a measurement in a randomly chosen basis
        c = circuit.copy()
        c.add(gates.M(*range(num_qubits), basis = [Pauli[measurement_basis[i][j]] for j in range(num_qubits)]))
        outcomes[i] = c(nshots = 1).samples(binary = True)[0]
    
    # Possible states in matrix form
    states = [np.array([[1, 0],[0, 0]]), np.array([[0, 0], [0, 1]])]
    # Matrices to invert the implicit unitary operations performed when measuring in different basis
    unitaries = [gates.H(0).matrix(), gates.H(0).matrix()@gates.S(0).dagger().matrix(), gates.I(0).matrix()]
    shadow = np.empty((shadow_size, num_qubits), dtype = np.ndarray)

    # Computes the classical shadows for each snapshots
    for i in range(shadow_size):
        for j in range(num_qubits):
            state = states[int(outcomes[i][j])]
            U = unitaries[measurement_basis[i][j]]
            shadow[i][j] = 3*(U.conj().T @ state @ U) - np.eye(2)

    return shadow

"""Returns a bound on the size of a classical shadow such that the estimation of 
the observables yields a maximum error with a certain failure rate"""
def shadow_bound(observables, error = 0.01, failure_rate = 0.01, locality = 1):
    M = np.size(observables, axis = 0)
    infty_norm = max([norm(obs, ord = np.inf) for obs in observables])
    return int((4**(locality + 1))/(error**2)*np.log(2*M/failure_rate)*(infty_norm**2))

"""Creates a 2-local block for an alternating layered ansatz"""
def S_block(theta):
    c = Circuit(2)
    c.add(gates.RX(0, theta[0]))
    c.add(gates.RY(0, theta[1]))
    c.add(gates.RX(0, theta[2]))
    c.add(gates.RX(1, theta[3]))
    c.add(gates.RY(1, theta[4]))
    c.add(gates.RX(1, theta[5]))
    c.add(gates.CNOT(0, 1))
    c.add(gates.RX(0, theta[6]))
    c.add(gates.RY(0, theta[7]))
    c.add(gates.RX(0, theta[8]))
    c.add(gates.RX(1, theta[9]))
    c.add(gates.RY(1, theta[10]))
    c.add(gates.RX(1, theta[11]))
    c.add(gates.CNOT(1, 0))
    return c

"""Given a set of (num_qubits//2)*depth*12 angles, generates an alternating layered ansatz"""
def alternating_layered_ansatz(depth, num_qubits, theta, density_matrix = True):
    c = Circuit(num_qubits, density_matrix = density_matrix)
    for j in range(depth):
        for i in range(num_qubits//2):
            c.add(S_block(theta[i][j]).on_qubits((2*(i - 1) + j)%num_qubits, (2*(i - 1)+ j + 1)%num_qubits))
    return c

"""An infidelity-like 1-local cost function for the state preparation problem"""
def cost(theta, observables, reduced_shadows, num_qubits, depth, rho):

    global file

    s = 0
    c = alternating_layered_ansatz(depth, num_qubits, theta.reshape(num_qubits//2, depth, 12))

    #For maximum efficency, we exploit the locality of the observables and make use only of the necessary dimensions
    for i in range(num_qubits):
        u = c.light_cone(i)[0].unitary()
        s += (u.conj().T@observables[i]@u@reduced_shadows[i]).trace()
        
    file.write(str(abs(1-s)) + " " + str(abs(infidelity(c().state(), rho))) + "\n")
    print(str(abs(1-s)) + " " + str(abs(infidelity(c().state(), rho))) + "\n")
    return abs(1 - s)

def infidelity_vs_shadow_size(num_qubits, depth, iterations):

    global file 
    
    if(num_qubits == 2):
        file = open("datos/infidelity_vs_shadow_size_2.txt", 'a')
    elif(num_qubits == 4):
        file = open("datos/infidelity_vs_shadow_size_4.txt", 'a')
    elif(num_qubits == 6):
        file = open("datos/infidelity_vs_shadow_size_6.txt", 'a')
    elif(num_qubits == 8):
        file = open("datos/infidelity_vs_shadow_size_8.txt", 'a')

    for _ in range(iterations):

        #Generation of random alternating layered ansatz and reduced observables
        rng = np.random.default_rng()
        theta = rng.uniform(0, 2*np.pi, ((num_qubits//2), depth, 12))
        c = alternating_layered_ansatz(depth, num_qubits, theta)
        rho = c().state()
        c = alternating_layered_ansatz(depth, num_qubits, theta, False)
        A = [c.light_cone(i)[1] for i in range(num_qubits)]
        observables = [(I(A[i][i]).full_matrix(len(A[i])) + Z(A[i][i]).full_matrix(len(A[i])))/(2*num_qubits) for i in range(num_qubits)]
        x = np.round((shadow_bound(observables)**(1/100))**np.arange(1, 101))

        for size in x:
            
            #Generation of the classical shadow and reduced shadows
            shadow = calculate_classical_shadow(c, int(size), num_qubits)
            rho_shadow = 0
            for i in range(int(size)):
                rho_snapshot = [1]
                for j in range(num_qubits):
                    rho_snapshot = np.kron(rho_snapshot, shadow[i][j])
                rho_shadow += 1/size*rho_snapshot
            file.write(str(size) + " " + str(abs(infidelity(rho_shadow, rho))) + "\n")
            print(str(size) + " " + str(abs(infidelity(rho_shadow, rho))) + "\n")

        file.write("---\n")
        print("---\n")


    file.close()

def infidelity_vs_iterations(num_qubits, depth, iterations):
    
    global file 

    if(num_qubits == 2):
        file = open("datos/infidelity_vs_iterations_2.txt", 'a')
    elif(num_qubits == 4):
        file = open("datos/infidelity_vs_iterations_4.txt", 'a')
    elif(num_qubits == 6):
        file = open("datos/infidelity_vs_iterations_6.txt", 'a')
    elif(num_qubits == 8):
        file = open("datos/infidelity_vs_iterations_8.txt", 'a')
        

    for _ in range(iterations):

        #Generation of random alternating layered ansatz and reduced observables
        rng = np.random.default_rng()
        theta = rng.uniform(0, 2*np.pi, ((num_qubits//2), depth, 12))
        c = alternating_layered_ansatz(depth, num_qubits, theta)
        A = [c.light_cone(i)[1] for i in range(num_qubits)]
        observables = [(I(A[i][i]).full_matrix(len(A[i])) + Z(A[i][i]).full_matrix(len(A[i])))/(2*num_qubits) for i in range(num_qubits)]
        rho = c().state()

        #Generation of the classical shadow and reduced shadows
        shadow = calculate_classical_shadow(c, shadow_bound(observables), num_qubits)
        reduced_shadows = np.zeros(num_qubits, dtype = np.ndarray)
        T = np.size(shadow, axis = 0)
        for i in range(num_qubits):
            for j in range(T):
                hat_rho = [1/T]
                for k in list(A[i]):
                    hat_rho = np.kron(hat_rho, shadow[j][k])
                reduced_shadows[i] = reduced_shadows[i] + hat_rho

        #Optimization procedure
        initial_theta = np.zeros((num_qubits//2)*depth*12)
        best, params, extra = optimize(cost, initial_theta, args = (observables, reduced_shadows, num_qubits, depth, rho), method = 'L-BFGS-B', options = {'maxiter': 100})
        file.write("---\n")
        print("---\n")
        file.close()
        if(num_qubits == 2):
            file = open("datos/infidelity_vs_iterations_2.txt", 'a')
        elif(num_qubits == 4):
            file = open("datos/infidelity_vs_iterations_4.txt", 'a')
        elif(num_qubits == 6):
            file = open("datos/infidelity_vs_iterations_6.txt", 'a')
        elif(num_qubits == 8):
            file = open("datos/infidelity_vs_iterations_8.txt", 'a')

    file.write("---\n")
    print("---\n")
    file.close()

infidelity_vs_shadow_size(4, 2, 10)